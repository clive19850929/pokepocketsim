diff --git a/pokepocketsim/debug_dump.py b/pokepocketsim/debug_dump.py
index 198d6b9..6da4d90 100644
--- a/pokepocketsim/debug_dump.py
+++ b/pokepocketsim/debug_dump.py
@@ -7,6 +7,27 @@ import time
 import uuid
 from typing import Any, Dict, Iterable, Optional
 
+import config
+
+
+def _get_log_base_dir() -> Optional[str]:
+    env_dir = os.getenv("POKEPOCKETSIM_LOG_DIR") or os.getenv("GAMELOG_DIR")
+    if env_dir:
+        return env_dir
+    base_dir = getattr(config, "GAMELOG_DIR", None)
+    if base_dir:
+        return base_dir
+    return None
+
+
+def _resolve_dump_dir(dump_dir: Optional[str]) -> str:
+    if dump_dir:
+        return dump_dir
+    base_dir = _get_log_base_dir()
+    if base_dir:
+        return os.path.join(base_dir, "debug_dumps")
+    return "debug_dumps"
+
 
 def _traceback_head(traceback_payload: Any, max_lines: int = 10) -> list[str]:
     if isinstance(traceback_payload, list):
@@ -77,14 +98,27 @@ def _save_seen_signatures(path: str, signatures: Iterable[str]) -> None:
 
 def write_debug_dump(
     payload: Dict[str, Any],
-    dump_dir: str = "debug_dumps",
-    signature_dir: str = "logs",
+    dump_dir: Optional[str] = None,
+    signature_dir: Optional[str] = None,
 ) -> Optional[str]:
     signature_hash = _signature_hash(payload)
+    dump_dir = _resolve_dump_dir(dump_dir)
+    signature_dir = signature_dir or dump_dir
     seen_path = os.path.join(signature_dir, "seen_signatures.json")
     seen = _load_seen_signatures(seen_path)
     if signature_hash in seen:
         print(f"[DEBUG_DUMP][SKIP] signature={signature_hash} already seen", flush=True)
+        if os.getenv("DEBUG_DUMP_LATEST", "0") == "1":
+            os.makedirs(dump_dir, exist_ok=True)
+            latest_path = os.path.join(dump_dir, "latest_debug_dump.json")
+            payload = dict(payload)
+            payload.setdefault("signature_hash", signature_hash)
+            try:
+                with open(latest_path, "w", encoding="utf-8") as f:
+                    json.dump(payload, f, ensure_ascii=False, indent=2)
+                print(f"[DEBUG_DUMP] wrote: {latest_path} mode=latest", flush=True)
+            except Exception:
+                pass
         return None
     seen.add(signature_hash)
     _save_seen_signatures(seen_path, seen)
@@ -102,4 +136,12 @@ def write_debug_dump(
     with open(path, "w", encoding="utf-8") as f:
         json.dump(payload, f, ensure_ascii=False, indent=2)
 
+    if os.getenv("DEBUG_DUMP_LATEST", "0") == "1":
+        latest_path = os.path.join(dump_dir, "latest_debug_dump.json")
+        try:
+            with open(latest_path, "w", encoding="utf-8") as f:
+                json.dump(payload, f, ensure_ascii=False, indent=2)
+        except Exception:
+            pass
+
     return path
diff --git a/pokepocketsim/player.py b/pokepocketsim/player.py
index 55d4ba7..397ae46 100644
--- a/pokepocketsim/player.py
+++ b/pokepocketsim/player.py
@@ -1,5 +1,8 @@
 from __future__ import annotations
-import random, copy
+import copy
+import hashlib
+import os
+import random
 from typing import (
     List,
     Optional,
@@ -797,6 +800,224 @@ class Player:
         except Exception:
             pass
 
+        try:
+            summary = getattr(self, "_last_decision_summary", None)
+            detail_state = getattr(self, "_last_decision_detail_state", None)
+            if isinstance(summary, dict):
+                def _coerce_vec5(vec):
+                    if isinstance(vec, tuple):
+                        vec = list(vec)
+                    if not isinstance(vec, list):
+                        return None
+                    out = list(vec)
+                    if len(out) < 5:
+                        out = out + [0] * (5 - len(out))
+                    if len(out) > 5:
+                        out = out[:5]
+                    return out
+
+                def _action_vec(action_obj):
+                    vec = None
+                    try:
+                        fn = getattr(action_obj, "to_id_vec", None)
+                        if callable(fn):
+                            try:
+                                vec = fn(player=self)
+                            except TypeError:
+                                vec = fn(self)
+                    except Exception:
+                        vec = None
+                    if vec is None:
+                        try:
+                            fn = getattr(action_obj, "serialize", None)
+                            if callable(fn):
+                                try:
+                                    vec = fn(player=self)
+                                except TypeError:
+                                    vec = fn(self)
+                        except Exception:
+                            vec = None
+                    return _coerce_vec5(vec)
+
+                applied_vec = _action_vec(action)
+                selected_vec = summary.get("selected_action_vec", None)
+                applied_matches_selected = None
+                if selected_vec is not None and applied_vec is not None:
+                    try:
+                        applied_matches_selected = bool(_coerce_vec5(selected_vec) == _coerce_vec5(applied_vec))
+                    except Exception:
+                        applied_matches_selected = None
+
+                summary["applied_matches_selected"] = applied_matches_selected
+                if isinstance(detail_state, dict):
+                    try:
+                        state_dict = detail_state.get("state_dict", None)
+                        if isinstance(state_dict, dict):
+                            state_dict["decision_applied_matches_selected"] = applied_matches_selected
+                    except Exception:
+                        pass
+
+                self.log_print(
+                    "[DECISION_SUMMARY]"
+                    f" event_id={summary.get('event_id')}"
+                    f" game_id={summary.get('game_id')}"
+                    f" turn={summary.get('turn')}"
+                    f" player={summary.get('player')}"
+                    f" pid={summary.get('pid')}"
+                    f" forced_active={summary.get('forced_active')}"
+                    f" forced_len={summary.get('forced_len')}"
+                    f" n_actions={summary.get('n_actions')}"
+                    f" state_fingerprint={summary.get('state_fingerprint')}"
+                    f" selected_idx={summary.get('selected_idx')}"
+                    f" selected_action_vec={summary.get('selected_action_vec')}"
+                    f" selected_source={summary.get('selected_source')}"
+                    f" selected_in_legal_actions={summary.get('selected_in_legal_actions')}"
+                    f" applied_matches_selected={applied_matches_selected}",
+                )
+
+                if applied_matches_selected is False:
+                    try:
+                        from .debug_dump import write_debug_dump
+
+                        state_dict = detail_state.get("state_dict", None) if isinstance(detail_state, dict) else None
+                        action_list = detail_state.get("actions", None) if isinstance(detail_state, dict) else None
+
+                        def _digest_vec(vec):
+                            if isinstance(vec, tuple):
+                                vec = list(vec)
+                            if not isinstance(vec, list):
+                                return "NA"
+                            try:
+                                raw = json.dumps(vec, ensure_ascii=False, sort_keys=True, separators=(",", ":"))
+                            except Exception:
+                                raw = str(vec)
+                            return hashlib.sha1(raw.encode("utf-8")).hexdigest()[:10]
+
+                        legal_actions_serialized = []
+                        try:
+                            for i, a in enumerate(action_list or []):
+                                legal_actions_serialized.append(
+                                    {
+                                        "i": i,
+                                        "action_type": getattr(a, "action_type", None),
+                                        "name": getattr(a, "name", None),
+                                        "vec": _action_vec(a),
+                                    }
+                                )
+                        except Exception:
+                            legal_actions_serialized = []
+
+                        cand_vecs = None
+                        try:
+                            if isinstance(state_dict, dict):
+                                cand_vecs = (
+                                    state_dict.get("cand_vecs", None)
+                                    or state_dict.get("action_candidates_vec", None)
+                                    or state_dict.get("action_candidates_vecs", None)
+                                )
+                        except Exception:
+                            cand_vecs = None
+
+                        cand_map = []
+                        if isinstance(cand_vecs, list):
+                            try:
+                                for i, row in enumerate(cand_vecs):
+                                    cand_map.append({"i": i, "cand_vec_digest": _digest_vec(row)})
+                            except Exception:
+                                cand_map = []
+
+                        pi = None
+                        try:
+                            if isinstance(state_dict, dict):
+                                pi = state_dict.get("pi", None) or state_dict.get("mcts_pi", None) or state_dict.get("policy_pi", None)
+                        except Exception:
+                            pi = None
+
+                        def _topk(arr, k=5):
+                            if not isinstance(arr, list):
+                                return None
+                            try:
+                                order = sorted(range(len(arr)), key=lambda i: float(arr[i]), reverse=True)[:k]
+                                return [{"i": int(i), "p": float(arr[i])} for i in order]
+                            except Exception:
+                                return None
+
+                        mcts_debug = None
+                        try:
+                            if isinstance(state_dict, dict):
+                                mcts_debug = state_dict.get("az_mcts_debug", None)
+                        except Exception:
+                            mcts_debug = None
+
+                        mcts_ctx = None
+                        if isinstance(mcts_debug, dict):
+                            visits = mcts_debug.get("visits")
+                            q_vals = mcts_debug.get("q")
+                            priors = mcts_debug.get("prior")
+                            mcts_ctx = {
+                                "mcts_enabled": True,
+                                "sims": mcts_debug.get("sims"),
+                                "visits_topK": _topk(visits),
+                                "q_topK": _topk(q_vals),
+                                "prior_topK": _topk(priors),
+                            }
+
+                        mix_ctx = None
+                        if isinstance(state_dict, dict):
+                            mix_ctx = {
+                                "lam": state_dict.get("mix_lam", None),
+                                "tau": state_dict.get("mix_tau", None),
+                                "mcts_idx": state_dict.get("mcts_idx", None),
+                                "mix_idx": state_dict.get("mix_idx", None),
+                                "final_idx": summary.get("selected_idx"),
+                                "changed": state_dict.get("mix_changed", None),
+                            }
+
+                        detail_payload = {
+                            "event_id": summary.get("event_id"),
+                            "game_id": summary.get("game_id"),
+                            "turn": summary.get("turn"),
+                            "player": summary.get("player"),
+                            "forced_active": summary.get("forced_active"),
+                            "forced_len": summary.get("forced_len"),
+                            "n_actions": summary.get("n_actions"),
+                            "state_fingerprint": summary.get("state_fingerprint"),
+                            "selected_idx": summary.get("selected_idx"),
+                            "selected_action_vec": summary.get("selected_action_vec"),
+                            "selected_source": summary.get("selected_source"),
+                            "selected_in_legal_actions": summary.get("selected_in_legal_actions"),
+                            "applied_matches_selected": applied_matches_selected,
+                            "legal_actions_serialized": legal_actions_serialized,
+                            "candidate_vecs": cand_map,
+                            "pi_topK": _topk(pi),
+                            "mcts_context": mcts_ctx,
+                            "mix_context": mix_ctx,
+                            "trigger": "applied_matches_selected=false",
+                        }
+
+                        self.log_print(
+                            "[DECISION_DETAIL]"
+                            f" event_id={summary.get('event_id')}"
+                            f" trigger=applied_matches_selected=false"
+                            f" selected_idx={summary.get('selected_idx')}"
+                            f" selected_source={summary.get('selected_source')}"
+                            f" applied_matches_selected={applied_matches_selected}",
+                        )
+
+                        dump_path = write_debug_dump(detail_payload)
+                        if dump_path is not None:
+                            try:
+                                cwd = os.getcwd()
+                                rel = os.path.relpath(dump_path, cwd)
+                            except Exception:
+                                cwd = None
+                                rel = dump_path
+                            self.log_print(f"[DEBUG_DUMP] wrote: {rel} cwd={cwd}")
+                    except Exception:
+                        pass
+        except Exception:
+            pass
+
         # ★ 追加：実行アクションをコンソールに即出力（人/CPU共通）
         try:
             turn_str = f"{self.match.turn}" if self.match else "?"
@@ -2821,6 +3042,150 @@ class Player:
                     except Exception:
                         pass
 
+                    def _record_decision_summary(idx_value, state_data, action_list):
+                        def _coerce_vec5(vec):
+                            if isinstance(vec, tuple):
+                                vec = list(vec)
+                            if not isinstance(vec, list):
+                                return [0, 0, 0, 0, 0]
+                            out = list(vec)
+                            if len(out) < 5:
+                                out = out + [0] * (5 - len(out))
+                            if len(out) > 5:
+                                out = out[:5]
+                            return out
+
+                        def _action_vec(action_obj):
+                            vec = None
+                            try:
+                                fn = getattr(action_obj, "to_id_vec", None)
+                                if callable(fn):
+                                    try:
+                                        vec = fn(player=self)
+                                    except TypeError:
+                                        vec = fn(self)
+                            except Exception:
+                                vec = None
+                            if vec is None:
+                                try:
+                                    fn = getattr(action_obj, "serialize", None)
+                                    if callable(fn):
+                                        try:
+                                            vec = fn(player=self)
+                                        except TypeError:
+                                            vec = fn(self)
+                                except Exception:
+                                    vec = None
+                            return _coerce_vec5(vec)
+
+                        event_id = None
+                        if isinstance(state_data, dict):
+                            try:
+                                event_id = state_data.get("la5_event_id", None) or state_data.get("decision_event_id", None)
+                            except Exception:
+                                event_id = None
+                        if event_id is None:
+                            try:
+                                m = getattr(self, "match", None)
+                                gid = getattr(m, "game_id", None) if m is not None else None
+                                turn = getattr(m, "turn", None) if m is not None else None
+                                seq = int(getattr(self, "_decision_seq", 0) or 0) + 1
+                                self._decision_seq = seq
+                                event_id = f"{gid}:{getattr(self, 'name', None)}:{turn}:{seq}"
+                            except Exception:
+                                event_id = None
+
+                        if isinstance(state_data, dict):
+                            try:
+                                state_data["decision_event_id"] = event_id
+                            except Exception:
+                                pass
+
+                        forced_active = None
+                        forced_len = None
+                        game_id = None
+                        turn = None
+                        pid = None
+                        try:
+                            m = getattr(self, "match", None)
+                            game_id = getattr(m, "game_id", None) if m is not None else None
+                            turn = getattr(m, "turn", None) if m is not None else None
+                            fa = getattr(m, "forced_actions", None) if m is not None else None
+                            if isinstance(fa, (list, tuple)):
+                                forced_len = int(len(fa))
+                                forced_active = forced_len > 0
+                        except Exception:
+                            forced_active = None
+                            forced_len = None
+                        try:
+                            pid = getattr(self, "pid", None)
+                        except Exception:
+                            pid = None
+
+                        selected_vec = None
+                        selected_in_legal_actions = None
+                        la_5 = None
+                        if isinstance(state_data, dict):
+                            try:
+                                la_5 = state_data.get("legal_actions_5", None)
+                            except Exception:
+                                la_5 = None
+                        try:
+                            if isinstance(la_5, list) and 0 <= int(idx_value) < len(la_5):
+                                selected_vec = la_5[int(idx_value)]
+                                selected_in_legal_actions = True
+                            elif action_list and 0 <= int(idx_value) < len(action_list):
+                                selected_vec = _action_vec(action_list[int(idx_value)])
+                                selected_in_legal_actions = (
+                                    isinstance(la_5, list) and selected_vec in la_5
+                                )
+                        except Exception:
+                            selected_vec = None
+                            selected_in_legal_actions = None
+
+                        selected_source = None
+                        if isinstance(state_data, dict):
+                            try:
+                                selected_source = state_data.get("online_mix_source", None) or state_data.get("az_decision_src", None)
+                            except Exception:
+                                selected_source = None
+                        if selected_source is None:
+                            try:
+                                selected_source = getattr(self.policy, "last_decision_src", None) or getattr(self.policy, "last_source", None)
+                            except Exception:
+                                selected_source = None
+
+                        state_fp = None
+                        if isinstance(state_data, dict):
+                            try:
+                                state_fp = state_data.get("trace_state_fingerprint", None) or state_data.get("env_state_fingerprint", None)
+                            except Exception:
+                                state_fp = None
+
+                        try:
+                            self._last_decision_summary = {
+                                "event_id": event_id,
+                                "game_id": game_id,
+                                "turn": turn,
+                                "player": getattr(self, "name", None),
+                                "pid": pid,
+                                "forced_active": forced_active,
+                                "forced_len": forced_len,
+                                "n_actions": int(len(action_list)) if isinstance(action_list, list) else None,
+                                "state_fingerprint": state_fp,
+                                "selected_idx": int(idx_value),
+                                "selected_action_vec": selected_vec,
+                                "selected_source": selected_source,
+                                "selected_in_legal_actions": selected_in_legal_actions,
+                            }
+                            self._last_decision_detail_state = {
+                                "event_id": event_id,
+                                "state_dict": state_data,
+                                "actions": action_list,
+                            }
+                        except Exception:
+                            pass
+
                     idx = self.policy.select_action_index_online(sd2, actions, player=self)
                     if isinstance(idx, int) and 0 <= idx < len(actions):
                         try:
@@ -2848,6 +3213,10 @@ class Player:
                                     pend.append("[DECIDE_DIFF] " + info)
                         except Exception:
                             pass
+                        try:
+                            _record_decision_summary(idx, sd2, actions)
+                        except Exception:
+                            pass
                         return idx
             except Exception:
                 # 失敗しても既存ロジックにフォールバック
@@ -2896,6 +3265,10 @@ class Player:
 
                 idx = self.policy.select_action_index(state_dict, actions, player=self)
                 if isinstance(idx, int) and 0 <= idx < len(actions):
+                    try:
+                        _record_decision_summary(idx, state_dict, actions)
+                    except Exception:
+                        pass
                     return idx
             except Exception:
                 # 例外時はランダムにフォールバック
@@ -3183,4 +3556,4 @@ def parse_action_text(text):
         m = re.search(r"\] (.+)の効果を使用", text)
         return ["stadium_effect", m.group(1)] if m else ["unknown", text]
     else:
-        return ["unknown", text]
\ No newline at end of file
+        return ["unknown", text]
diff --git a/pokepocketsim/policy/az_mcts_policy.py b/pokepocketsim/policy/az_mcts_policy.py
index a717a2c..823668d 100644
--- a/pokepocketsim/policy/az_mcts_policy.py
+++ b/pokepocketsim/policy/az_mcts_policy.py
@@ -590,8 +590,6 @@ class AlphaZeroMCTSPolicy:
                     },
                     "traceback": traceback.format_exception(type(e), e, e.__traceback__),
                 }
-                import os
-
                 dump_path = write_debug_dump(payload)
                 if dump_path is not None:
                     try:
@@ -751,6 +749,7 @@ class AlphaZeroMCTSPolicy:
             try:
                 state_dict["az_decision_src"] = str(getattr(self, "last_decision_src", "unknown"))
                 state_dict["az_decision_pick"] = str(getattr(self, "last_pick", "unknown"))
+                state_dict["az_mcts_debug"] = getattr(self, "_last_mcts_detail", None)
             except Exception:
                 pass
 
@@ -1348,6 +1347,22 @@ class AlphaZeroMCTSPolicy:
                 raise RuntimeError("[AZ][MCTS] pi normalization failed (no fallback).")
             pi = [float(x) / s for x in ww]
 
+        try:
+            q_values: List[float] = []
+            prior_values: List[float] = []
+            for k in root_keys:
+                child = root.children.get(k)
+                q_values.append(float(getattr(child, "Q", 0.0)) if child is not None else 0.0)
+                prior_values.append(float(getattr(child, "P", 0.0)) if child is not None else 0.0)
+            self._last_mcts_detail = {
+                "sims": int(sims),
+                "visits": [float(x) for x in visit_counts],
+                "q": q_values,
+                "prior": prior_values,
+            }
+        except Exception:
+            pass
+
         try:
             if os.getenv("AZ_MCTS_DEBUG", "0") == "1":
                 elapsed_ms = None
diff --git a/pokepocketsim/policy/online_mixed_policy.py b/pokepocketsim/policy/online_mixed_policy.py
index 1a6184b..dd2264e 100644
--- a/pokepocketsim/policy/online_mixed_policy.py
+++ b/pokepocketsim/policy/online_mixed_policy.py
@@ -1,4 +1,7 @@
 from __future__ import annotations
+import hashlib
+import json
+import os
 from typing import Any, List, Optional
 
 
@@ -1873,6 +1876,41 @@ class OnlineMixedPolicy:
 
         # ★追加: 手ごとの決定ソース/idx を state_dict と last_decide_info に確実に残す（printはここではしない）
         def _set_online_mix_trace(_source, _idx, _why=None):
+            def _coerce_vec5(vec):
+                if isinstance(vec, tuple):
+                    vec = list(vec)
+                if not isinstance(vec, list):
+                    return [0, 0, 0, 0, 0]
+                out = list(vec)
+                if len(out) < 5:
+                    out = out + [0] * (5 - len(out))
+                if len(out) > 5:
+                    out = out[:5]
+                return out
+
+            def _action_vec(action):
+                vec = None
+                try:
+                    fn = getattr(action, "to_id_vec", None)
+                    if callable(fn):
+                        try:
+                            vec = fn(player=player)
+                        except TypeError:
+                            vec = fn(player)
+                except Exception:
+                    vec = None
+                if vec is None:
+                    try:
+                        fn = getattr(action, "serialize", None)
+                        if callable(fn):
+                            try:
+                                vec = fn(player=player)
+                            except TypeError:
+                                vec = fn(player)
+                    except Exception:
+                        vec = None
+                return _coerce_vec5(vec)
+
             try:
                 self.last_source = str(_source)
             except Exception:
@@ -1931,8 +1969,8 @@ class OnlineMixedPolicy:
                                 self.pi = pi_norm
                             except Exception:
                                 pass
-            except Exception:
-                pass
+                except Exception:
+                    pass
 
             try:
                 self.last_decide_info = {
@@ -1977,6 +2015,8 @@ class OnlineMixedPolicy:
                 state_dict["online_mix_p"] = float(self.mix_prob)
                 if _why is not None:
                     state_dict["online_mix_why"] = str(_why)
+                state_dict["decision_selected_idx"] = int(_idx)
+                state_dict["decision_selected_source"] = str(_source)
             except Exception:
                 pass
 
@@ -2041,6 +2081,214 @@ class OnlineMixedPolicy:
                 except Exception:
                     pass
 
+            try:
+                event_id = state_dict.get("la5_event_id", None)
+                if event_id is None:
+                    event_id = self._next_la5_event_id()
+                    state_dict["la5_event_id"] = event_id
+            except Exception:
+                event_id = None
+
+            try:
+                la_5 = state_dict.get("legal_actions_5", None)
+            except Exception:
+                la_5 = None
+
+            selected_vec = None
+            selected_in_legal_actions = None
+            try:
+                if isinstance(la_5, list) and 0 <= int(_idx) < len(la_5):
+                    selected_vec = la_5[int(_idx)]
+                    selected_in_legal_actions = True
+                else:
+                    selected_vec = _action_vec(actions[int(_idx)])
+                    selected_in_legal_actions = (
+                        isinstance(la_5, list) and selected_vec in la_5
+                    )
+            except Exception:
+                selected_vec = None
+                selected_in_legal_actions = None
+
+            try:
+                state_dict["decision_selected_vec"] = selected_vec
+                state_dict["decision_selected_in_legal_actions"] = selected_in_legal_actions
+            except Exception:
+                pass
+
+            try:
+                mcts_idx = state_dict.get("mcts_idx", None)
+            except Exception:
+                mcts_idx = None
+            final_idx = int(_idx)
+            changed = None
+            try:
+                if mcts_idx is not None:
+                    changed = int(int(mcts_idx) != int(final_idx))
+            except Exception:
+                changed = None
+
+            try:
+                state_dict["mix_idx"] = final_idx
+                state_dict["final_idx"] = final_idx
+                if mcts_idx is not None:
+                    state_dict["mix_changed"] = changed
+            except Exception:
+                pass
+
+            try:
+                if selected_in_legal_actions is False or (changed == 1):
+                    from ..debug_dump import write_debug_dump
+
+                    def _digest_vec(vec):
+                        if isinstance(vec, tuple):
+                            vec = list(vec)
+                        if not isinstance(vec, list):
+                            return "NA"
+                        try:
+                            raw = json.dumps(vec, ensure_ascii=False, sort_keys=True, separators=(",", ":"))
+                        except Exception:
+                            raw = str(vec)
+                        return hashlib.sha1(raw.encode("utf-8")).hexdigest()[:10]
+
+                    legal_actions_serialized = []
+                    try:
+                        for i, a in enumerate(actions or []):
+                            legal_actions_serialized.append(
+                                {
+                                    "i": i,
+                                    "action_type": getattr(a, "action_type", None),
+                                    "name": getattr(a, "name", None),
+                                    "vec": _action_vec(a),
+                                }
+                            )
+                    except Exception:
+                        legal_actions_serialized = []
+
+                    cand_vecs = None
+                    try:
+                        cand_vecs = (
+                            state_dict.get("cand_vecs", None)
+                            or state_dict.get("action_candidates_vec", None)
+                            or state_dict.get("action_candidates_vecs", None)
+                        )
+                    except Exception:
+                        cand_vecs = None
+
+                    cand_map = []
+                    if isinstance(cand_vecs, list):
+                        try:
+                            for i, row in enumerate(cand_vecs):
+                                cand_map.append({"i": i, "cand_vec_digest": _digest_vec(row)})
+                        except Exception:
+                            cand_map = []
+
+                    pi = None
+                    try:
+                        pi = state_dict.get("pi", None) or state_dict.get("mcts_pi", None) or state_dict.get("policy_pi", None)
+                    except Exception:
+                        pi = None
+
+                    def _topk(arr, k=5):
+                        if not isinstance(arr, list):
+                            return None
+                        try:
+                            order = sorted(range(len(arr)), key=lambda i: float(arr[i]), reverse=True)[:k]
+                            return [{"i": int(i), "p": float(arr[i])} for i in order]
+                        except Exception:
+                            return None
+
+                    mcts_debug = None
+                    try:
+                        mcts_debug = state_dict.get("az_mcts_debug", None)
+                    except Exception:
+                        mcts_debug = None
+
+                    mcts_ctx = None
+                    if isinstance(mcts_debug, dict):
+                        visits = mcts_debug.get("visits")
+                        q_vals = mcts_debug.get("q")
+                        priors = mcts_debug.get("prior")
+                        mcts_ctx = {
+                            "mcts_enabled": True,
+                            "sims": mcts_debug.get("sims"),
+                            "visits_topK": _topk(visits),
+                            "q_topK": _topk(q_vals),
+                            "prior_topK": _topk(priors),
+                        }
+
+                    mix_ctx = {
+                        "lam": state_dict.get("mix_lam", None) if isinstance(state_dict, dict) else None,
+                        "tau": state_dict.get("mix_tau", None) if isinstance(state_dict, dict) else None,
+                        "mcts_idx": mcts_idx,
+                        "mix_idx": final_idx,
+                        "final_idx": final_idx,
+                        "changed": changed,
+                    }
+
+                    try:
+                        m = getattr(player, "match", None) if player is not None else None
+                        game_id = getattr(m, "game_id", None) if m is not None else None
+                        turn = getattr(m, "turn", None) if m is not None else None
+                        fa = getattr(m, "forced_actions", None) if m is not None else None
+                        forced_len = int(len(fa)) if isinstance(fa, (list, tuple)) else None
+                        forced_active = (forced_len > 0) if forced_len is not None else None
+                        player_name = getattr(player, "name", None) if player is not None else None
+                    except Exception:
+                        game_id = None
+                        turn = None
+                        forced_active = None
+                        forced_len = None
+                        player_name = None
+
+                    state_fp = None
+                    try:
+                        state_fp = state_dict.get("trace_state_fingerprint", None) or state_dict.get("env_state_fingerprint", None)
+                    except Exception:
+                        state_fp = None
+
+                    detail_payload = {
+                        "event_id": event_id,
+                        "game_id": game_id,
+                        "turn": turn,
+                        "player": player_name,
+                        "forced_active": forced_active,
+                        "forced_len": forced_len,
+                        "n_actions": int(len(actions)) if isinstance(actions, list) else None,
+                        "state_fingerprint": state_fp,
+                        "selected_idx": int(final_idx),
+                        "selected_action_vec": selected_vec,
+                        "selected_source": str(_source),
+                        "selected_in_legal_actions": selected_in_legal_actions,
+                        "legal_actions_serialized": legal_actions_serialized,
+                        "candidate_vecs": cand_map,
+                        "pi_topK": _topk(pi),
+                        "mcts_context": mcts_ctx,
+                        "mix_context": mix_ctx,
+                        "trigger": "selected_in_legal_actions=false" if selected_in_legal_actions is False else "mcts_idx_changed",
+                    }
+
+                    print(
+                        "[DECISION_DETAIL]"
+                        f" event_id={event_id}"
+                        f" trigger={detail_payload.get('trigger')}"
+                        f" selected_idx={int(final_idx)}"
+                        f" selected_source={_source}"
+                        f" selected_in_legal_actions={selected_in_legal_actions}",
+                        flush=True,
+                    )
+
+                    dump_path = write_debug_dump(detail_payload)
+                    if dump_path is not None:
+                        try:
+                            cwd = os.getcwd()
+                            rel = os.path.relpath(dump_path, cwd)
+                        except Exception:
+                            cwd = None
+                            rel = dump_path
+                        print(f"[DEBUG_DUMP] wrote: {rel} cwd={cwd}", flush=True)
+            except Exception:
+                pass
+
             if str(_source) == "random" and _why is not None:
                 try:
                     game_id = None
@@ -2068,7 +2316,11 @@ class OnlineMixedPolicy:
                     event_id = None
                     try:
                         if isinstance(state_dict, dict):
-                            event_id = state_dict.get("last_step_no_match_event_id", None)
+                            event_id = (
+                                state_dict.get("la5_event_id", None)
+                                or state_dict.get("decision_event_id", None)
+                                or state_dict.get("last_step_no_match_event_id", None)
+                            )
                     except Exception:
                         event_id = None
                     if event_id is None:
